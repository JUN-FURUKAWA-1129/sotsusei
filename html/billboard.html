<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>掲示板</title>
        <link href="../styles/test-2.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <script id="vshader_box" src="../shaders/vertex_box.glsl" type="x-shader/v-shader">
            uniform float sec;

            varying  vec4 vColor;
            varying vec2 vUv;
            
            void main() {
                vColor = vec4(1.0-sin(sec)*0.5, 1.0, 0, 1.0);
                vUv=uv;
            
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vec4 mvPosition =  viewMatrix * worldPosition;
                gl_Position = projectionMatrix * mvPosition;
            }</script>
        <script id="fshader_box" src="../shaders/fragment_box.glsl" type="x-shader/f-shader">
            uniform float sec;
            uniform sampler2D texture0;
            
            varying vec2 vUv;
            varying vec4 vColor;
            
                void main() {
                    vec4 smpColor=texture2D(texture0,vUv);
                    gl_FragColor =vColor*smpColor;
                }</script>
        <script id="vshader_sky" src="../shaders/vertex_sky.glsl" type="x-shader/v-shader">
            uniform float sec;

            varying  vec4 vColor;
            varying vec2 vUv;
            
            void main() {
                vColor = vec4(1.0, 1.0, 1.0, 1.0);
                vUv=uv;
            
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vec4 mvPosition =  viewMatrix * worldPosition;
                gl_Position = projectionMatrix * mvPosition;
            }</script>
        <script id="fshader_sky" src="../shaders/fragment_sky.glsl" type="x-shader/f-shader">     
            uniform float sec;
            uniform sampler2D texture1;

            varying vec2 vUv;
            varying vec4 vColor;

            void main() {
            vec4 smpColor=texture2D(texture1,vUv);
            gl_FragColor =vColor*smpColor;
            }</script>


        <div id="canvas-container">
            <canvas id="myCanvas"></canvas>
        </div>

        <script type="module">

            import * as THREE from '../build/three.module.js';
            import { OrbitControls } from '../scripts/OrbitControls.js';
            import { Rhino3dmLoader } from '../scripts/3DMLoader.js';
            
            const vertexSource_box = document.getElementById("vshader_box").textContent;
            const fragmentSource_box = document.getElementById("fshader_box").textContent;
            const vertexSource_sky = document.getElementById("vshader_sky").textContent;
            const fragmentSource_sky = document.getElementById("fshader_sky").textContent;

			let container, controls;
			let camera, scene, renderer;
            let raycaster,mouse;
            let meshList;
			let target;
			let i;
            let Rhino;
            let sec;
            let dir;
            let camera_TP;

                init();
			    animate();
                OnResize();

			window.addEventListener("resize",OnResize);

			function init() {

                //setup
                mouse = new THREE.Vector2();
				const canvas=document.querySelector("#myCanvas");

				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 0, 1 );
				container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                //camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, - 10, 1.5 );
                var cam_target=new THREE.Vector3(0,0,0);
                camera.lookAt(cam_target);

                //camera_TP= new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
                //camera_TP.position.set( 0, - 10, 1.5 );
                //controls = new OrbitControls( camera_TP, container );

                scene = new THREE.Scene();
				canvas.addEventListener("mousemove",handleMouseMove);

				function handleMouseMove(event){
					const element = event.currentTarget;

					const x = event.clientX - element.offsetLeft;
					const y = event.clientY - element.offsetTop;

					const w = element.offsetWidth;
					const h = element.offsetHeight;

					mouse.x=(x/w)*2-1;
                    mouse.y=-(y/h)*2+1;

                    if(event.buttons===1){
                        cam_target.x-=event.movementX*0.1;
                        cam_target.z+=event.movementY*0.1;
                        camera.lookAt(cam_target);
                    }                    
                    /*if(controls.scope.enable){
                        dir = camera.getWorldDirection();
                    }*/
				}
				//light
				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 0, 0, 2 );
				directionalLight.castShadow = true;
				directionalLight.intensity = 0.2;
				scene.add( directionalLight );

				const ambientLight=new THREE.AmbientLight(0xffff,1.0);
				scene.add(ambientLight);

				meshList=[];
                //load .3dm data
                //square
				const loader = new Rhino3dmLoader();
				loader.setLibraryPath( '../scripts/' );

				loader.load( '../models/square.3dm', function ( object ) {
					object.name="square";
					Rhino=object;
					scene.add( object );
                } );

                //load images
                const tex_loader=new THREE.TextureLoader();
                const image0 = tex_loader.load("../images/cyber-city.jpg");
                const image1 = tex_loader.load("../images/sky.png");

                //add uniform variables
                container.uniforms={
                    sec:{
                        value: sec
                    },
                    texture0:{
                        value: image0
                    },
                    texture1:{
                        value: image1
                    }
                }

                //create geometry
                //sky
                const mySphere=new THREE.SphereGeometry(1000,32,32);
               const mat_sky=new THREE.ShaderMaterial({
                    uniforms: container.uniforms,
                    vertexShader: vertexSource_sky,
                    fragmentShader: fragmentSource_sky,
                    side: THREE.BackSide
                });
                const mesh0=new THREE.Mesh(mySphere,mat_sky);
                scene.add(mesh0);
                meshList.push(mesh0);

                //cylinder
				const myCylinder = new THREE.CylinderGeometry(1.5,1.5,0.3,32,4,true);
                const mat_box=new THREE.ShaderMaterial({
                    uniforms: container.uniforms,
                    vertexShader: vertexSource_box,
                    fragmentShader: fragmentSource_box
                });
                const material = new THREE.MeshStandardMaterial({
                    map: image0,
                    side: THREE.DoubleSide
                });
                const mesh1= new THREE.Mesh(myCylinder,material)
                mesh1.name="Cylinder";
                mesh1.position.set(0,0,3);
                mesh1.rotation.x=Math.PI/2;
                scene.add(mesh1);
                meshList.push(mesh1);
                
                //cube
                const myBox = new THREE.BoxBufferGeometry(1.5,1.5,1.5);
                const mesh2= new THREE.Mesh(myBox,mat_box);
                mesh2.name="Box";
                mesh2.position.set(0,0,1.75);
                scene.add(mesh2);
                meshList.push(mesh2);

                //avater
                const avater = new THREE.BoxBufferGeometry(1,1,2);
                const mesh3= new THREE.Mesh(avater,material);
                mesh3.name="avater";
                mesh3.position.set(3.0,3.0,1.0);
                scene.add(mesh3);
                meshList.push(mesh3);
                

				// create renderer
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { 
					antialias: true,
                    canvas: canvas,
                    alpha: true
				} );
				renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );
                renderer.setClearColor(0x000000,0);
				container.appendChild( renderer.domElement );

				raycaster = new THREE.Raycaster();

				animate();

				//eventlistener


				window.addEventListener( 'resize', resize, false );
                
                canvas.addEventListener("click",handleMouseMove,false);
                canvas.addEventListener("click",clickPosition,false);

				function clickPosition(event){
                    if(target.name==="Cylinder"){
                        console.log("You clicked cylinder!");
                    }
                    if(target.name==="Box"){
                        console.log("You clicked box!");
                    }
					/*scene.remove(target);
					i=meshList.indexOf(target);

					if(i!==-1){
						meshList.splice(i,1);
					}
					Rhino.position.x+=10;*/
                }
                
                dir = camera.getWorldDirection();

                document.addEventListener("keydown",move);
                function move(event){
                    var keyname=event.key;
                    if(keyname==="w"){
                        const pos=camera.position;
                        dir =camera.getWorldDirection();

                        pos.x+=dir.x*0.1;
                        pos.y+=dir.y*0.1;
                        pos.z+=dir.z*0.1;
                        cam_target.x+=dir.x*0.1;
                        cam_target.y+=dir.y*0.1;
                        cam_target.z+=dir.z*0.1;
                        
                        console.log(dir);
                    }

                    if(keyname==="s"){
                        const pos=camera.position;
                        dir =camera.getWorldDirection();

                        pos.x-=dir.x*0.1;
                        pos.y-=dir.y*0.1;
                        pos.z-=dir.z*0.1;
                        cam_target.x-=dir.x*0.1;
                        cam_target.y-=dir.y*0.1;
                        cam_target.z-=dir.z*0.1;
                        
                        console.log(dir);
                    }
                }
			}

			function resize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

                raycaster.setFromCamera(mouse,camera);
                sec = performance.now()/1000;
                container.uniforms.sec.value=sec;

                meshList.map(mesh=>{
                    if(mesh.name==="Box"){
                        mesh.rotation.z=sec*0.1;
                    }
                })

				const intersects = raycaster.intersectObjects(meshList);

				meshList.map(mesh => {
					if(intersects.length > 0 && mesh === intersects[0].object){
						target=mesh;
						//mesh.material.color.setHex(0xff0000);
					}else{
						//mesh.material.color.setHex(0xffffff);
					}
				})
				renderer.render( scene, camera);

				requestAnimationFrame( animate );

			}

			function OnResize(){
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer.setPixelRatio(window.devicePixelRation);
				renderer.setSize(width,height);

				camera.aspect =width/height;
				camera.updateProjectionMatrix();
			}

        </script>
    </body>
</html>