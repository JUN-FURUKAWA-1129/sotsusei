<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" >
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <title>掲示板</title>
        <link href="../styles/test-2.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="canvas-container">
            <canvas id="myCanvas"></canvas>
        </div>

        <script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from '../scripts/OrbitControls.js';
            import { Rhino3dmLoader } from '../scripts/3DMLoader.js';
            
            const vertexSource = `
            void main() {
      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vec4 mvPosition =  viewMatrix * worldPosition;
      gl_Position = projectionMatrix * mvPosition;
    }

            `;

            const fragmentSource = `
            void main() {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
            `;

			let container, controls;
			let camera, scene, renderer;
			let gui;
            let raycaster,mouse;
            let meshList;
			let target;
			let i;
            let Rhino;

			init();
			animate();

			OnResize();

			window.addEventListener("resize",OnResize);

			function init() {

                //setup
                mouse = new THREE.Vector2();
				const canvas=document.querySelector("#myCanvas");

				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 0, 1 );
				container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                //camera
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, - 10, 1.5 );

				scene = new THREE.Scene();

				//light
				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 0, 0, 2 );
				directionalLight.castShadow = true;
				directionalLight.intensity = 0.2;
				scene.add( directionalLight );

				const ambientLight=new THREE.AmbientLight(0xffff,0.1);
				scene.add(ambientLight);

				meshList=[];
                //load .3dm data
                //square
				const loader = new Rhino3dmLoader();
				loader.setLibraryPath( '../scripts/' );

				loader.load( '../models/square.3dm', function ( object ) {
					object.name="square";
					Rhino=object;
					scene.add( object );
				} );

                //create geometry
                //cylinder
				const myCylinder = new THREE.CylinderGeometry(1.5,1.5,0.3,32,4,true);
                const mat=new THREE.ShaderMaterial({
                    vertexShader: vertexSource,
                    fragmentShader: fragmentSource
                })
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });
                const mesh1= new THREE.Mesh(myCylinder,material)
                mesh1.name="Cylinder";
                mesh1.position.set(0,0,3);
                mesh1.rotation.x=Math.PI/2;
                scene.add(mesh1);
                meshList.push(mesh1);
                
                //cube
                const myBox = new THREE.BoxBufferGeometry(1.5,1.5,1.5);
                const mesh2= new THREE.Mesh(myBox,mat)
                mesh2.name="Box";
                mesh2.position.set(0,0,1.75);
                mesh2.rotation.x=Math.PI/2;
                scene.add(mesh2);
                meshList.push(mesh2);


				// create renderer
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { 
					antialias: true,
                    canvas: canvas,
                    alpha: true
				} );
				renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( width, height );
                renderer.setClearColor(0x000000,0);
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, container );

				raycaster = new THREE.Raycaster();

				animate();

				//eventlistener
				canvas.addEventListener("mousemove",handleMouseMove);

				function handleMouseMove(event){
					const element = event.currentTarget;

					const x = event.clientX - element.offsetLeft;
					const y = event.clientY - element.offsetTop;

					const w = element.offsetWidth;
					const h = element.offsetHeight;

					mouse.x=(x/w)*2-1;
					mouse.y=-(y/h)*2+1;
				}

				window.addEventListener( 'resize', resize, false );

                canvas.addEventListener("click",clickPosition,false);
                canvas.addEventListener("click",handleMouseMove,false);

				function clickPosition(event){
                    if(target.name==="Cylinder"){
                        alert("You clicked cylinder!");
                        target=null;
                    }
                    if(target.name==="Box"){
                        alert("You clicked box!");
                        target=null;
                    }
					/*scene.remove(target);
					i=meshList.indexOf(target);

					if(i!==-1){
						meshList.splice(i,1);
					}
					Rhino.position.x+=10;*/
                }
			}

			function resize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

                raycaster.setFromCamera(mouse,camera);
                const sec = performance.now()/1000;

                meshList[1].rotation.y=sec*0.1;

				const intersects = raycaster.intersectObjects(meshList);

				meshList.map(mesh => {
					if(intersects.length > 0 && mesh === intersects[0].object){
						target=mesh;
						//mesh.material.color.setHex(0xff0000);
					}else{
						//mesh.material.color.setHex(0xffffff);
					}
				})
				controls.update();
				renderer.render( scene, camera );

				requestAnimationFrame( animate );

			}

			function OnResize(){
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer.setPixelRatio(window.devicePixelRation);
				renderer.setSize(width,height);

				camera.aspect =width/height;
				camera.updateProjectionMatrix();
			}

        </script>
    </body>
</html>