<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - Rhino 3DM loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="test-2.css">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
	</head>

	<body>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from '../scripts/OrbitControls.js';
			import { Rhino3dmLoader } from '../scripts/3DMLoader.js';

			import { GUI } from '../scripts/dat.gui.module.js';

			let container, controls;
			let camera, scene, renderer;
			let gui;
			let raycaster,mouse,meshList;
			let target;
			let i;
			let Rhino;

			init();
			animate();

			OnResize();

			window.addEventListener("resize",OnResize);

			function init() {

				mouse = new THREE.Vector2();
				const canvas=document.querySelector("#canvas1");

				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 0, 1 );
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 26, - 40, 5 );

				scene = new THREE.Scene();

				//light
				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 0, 0, 2 );
				directionalLight.castShadow = true;
				directionalLight.intensity = 2;
				scene.add( directionalLight );

				const ambientLight=new THREE.AmbientLight(0xffff,0.1);
				scene.add(ambientLight);

				meshList=[];
				//load .3dm data
				const loader = new Rhino3dmLoader();
				loader.setLibraryPath( '../scripts/' );

				loader.load( '../models/Rhino_Logo.3dm', function ( object ) {
					object.name="Rhino_Logo";
					Rhino=object;
					scene.add( object );
					initGUI( object.userData.layers );
				} );

				loader.load( '../models/building.3dm', function ( object ) {
					scene.add( object );
					initGUI( object.userData.layers );
				} );	
				
				//create geometry
				const geometry = new THREE.BoxBufferGeometry(5,5,5);

				for(let i=0;i<200;i++){
					const material = new THREE.MeshStandardMaterial({color: 0xffffff});

					const mesh = new THREE.Mesh(geometry,material);
					mesh.position.x=(Math.random()-0.5)*80;
					mesh.position.y=(Math.random()-0.5)*80;
					mesh.position.z=(Math.random()-0.5)*80;
					mesh.rotation.x=Math.random()*2*Math.PI;
					mesh.rotation.y=Math.random()*2*Math.PI;
					mesh.rotation.z=Math.random()*2*Math.PI;
					scene.add(mesh);

					meshList.push(mesh);
				}

				// create renderer
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { 
					antialias: true,
					canvas: canvas 
				} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, container );

				raycaster = new THREE.Raycaster();

				animate();

				//eventlistener
				canvas.addEventListener("mousemove",hamdleMouseMove);

				function hamdleMouseMove(event){
					const element = event.currentTarget;

					const x = event.clientX - element.offsetLeft;
					const y = event.clientY - element.offsetTop;

					const w = element.offsetWidth;
					const h = element.offsetHeight;

					mouse.x=(x/w)*2-1;
					mouse.y=-(y/h)*2+1;
				}

				window.addEventListener( 'resize', resize, false );

				canvas.addEventListener("click",clickPosition,false);

				function clickPosition(event){
					scene.remove(target);
					i=meshList.indexOf(target);

					if(i!==-1){
						meshList.splice(i,1);
					}
					Rhino.position.x+=10;
				}
			}

			function resize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				raycaster.setFromCamera(mouse,camera);

				const intersects = raycaster.intersectObjects(meshList);

				meshList.map(mesh => {
					if(intersects.length > 0 && mesh === intersects[0].object){
						target=mesh;
						mesh.material.color.setHex(0xff0000);
					}else{
						mesh.material.color.setHex(0xffffff);
					}
				})
				controls.update();
				renderer.render( scene, camera );

				requestAnimationFrame( animate );

			}

			function initGUI( layers ) {

				gui = new GUI( { width: 300 } );
				const layersControl = gui.addFolder( 'layers' );
				layersControl.open();

				for ( let i = 0; i < layers.length; i ++ ) {

					const layer = layers[ i ];
					layersControl.add( layer, 'visible' ).name( layer.name ).onChange( function ( val ) {

						const name = this.object.name;

						scene.traverse( function ( child ) {

							if ( child.userData.hasOwnProperty( 'attributes' ) ) {

								if ( 'layerIndex' in child.userData.attributes ) {

									const layerName = layers[ child.userData.attributes.layerIndex ].name;

									if ( layerName === name ) {

										child.visible = val;
										layer.visible = val;

									}

								}

							}

						} );

					} );

				}

			}

			function OnResize(){
				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer.setPixelRatio(window.devicePixelRation);
				renderer.setSize(width,height);

				camera.aspect =width/height;
				camera.updateProjectionMatrix();
			}

		</script>

		<canvas id="canvas1"></canvas>

	</body>
</html>
